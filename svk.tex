% !Mode:: "TeX::UTF-8"
\documentclass{svk_long_sk}
%% ak pisete po anglicky, pouzijete namiesto horneho riadku
%% \documentclass{svk_long_en}
\usepackage{mathrsfs}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage[shortlabels]{enumitem}

%definície pre foju
%\newtheorem{veta}{Veta}[section] 
%\newtheorem{df}[veta]{Definícia}
%\newtheorem{lema}[veta]{Lema}
%\newtheorem{dosledok}[veta]{Dôsledok}
\def\R{{\cal R}} % znak pre regulárne jazyky
\def\L{\mathscr{L}} % zvyšné triedy jazykov
\def\P{{\cal P}} % potenčná množina
\def\N{\mathds{N}} %prirodzene cisla
\def\re{Regex}
\def\e{Eregex}
\def\le{LEregex}
\def\nle{nLEregex}
\def\rel{{\mathscr{L}_{RE}}}
\def\el{\mathscr{L}_{ERE}}
\def\lel{\mathscr{L}_{LERE}}
\def\nlel{\mathscr{L}_{nLERE}}
\def\lookahead{\text{(?=}}
\def\nlookahead{\text{(?!~}}
\def\lookbehind{\text{(?\textless =}}
\def\nlookbehind{\text{(?\textless !~}}

\begin{document}
\title{Moderné regulárne výrazy}

\author{Tatiana Tóthová
\email{tothova166@uniba.sk}}
%% vsimnite si, ze u autorov sa nepisu tituly
%% prikaz \inst sluzi ako odkaz do zoznamu institucii
%% (vid. nizsie)

%% skolitela nepiste medzi autorov, ale v tejto casti
%% ak praca nema skolitela, jednoducho vynechajte
\supervisor{Michal Fori\v{s}ek
\email{forisek@dcs.fmph.uniba.sk}}

%% nasleduje kratka verzia nazvu clanku a 
%% zoznam autorov (bez krstnych mien)
%% tieto informacie sa zobrazuju v hlavicke
\titlerunning{Moderné regulárne výrazy}
\authorrunning{Tóthová}

\institute{
Katedra informatiky,
FMFI UK,
Mlynská Dolina
842~48~Bratislava}

\maketitle

\begin{abstract}
Regulárne výrazy implementované v súčasných programovacích jazykoch ponúkajú omnoho viac operácií ako pôvodný model z teórie jazykov. Už konštrukciou spätných referencií bola prekročená hranica regulárnych jazykov. Náš model obsahuje naviac konštrukcie lookahead a lookbehind. V článku uvedieme zaradenie modelu zodpovedajúcej triedy jazykov do Chomského hierarchie, vlasnosti tejto triedy a výsledky z oblasti priestorovej zložitosti.

\keywords{regulárny výraz, regex, lookahead, lookbehind, spätné referencie}
\end{abstract}

\section{Úvod}
Regulárne výrazy vznikli v 60tych rokoch v teórii jazykov ako ďalší model na vyjadrenie regulárnych jazykov. Z takéhoto popisu ľudský mozog rýchlejšie pochopil o aký jazyk sa jedná, než zo zápisu konečného automatu, či regulárnej gramatiky. Ďalšou výhodou bol kratší a kompaktný zápis.

Vďaka týmto vlastnostiam boli implementované ako vyhľadávací nástroj. Postupom času sa iniciatívou používateľov s vyššími nárokmi pridávali nové konštrukcie na uľahčenie práce. Nástroj takto rozvíjali až do dnešnej podoby. My sa budeme opierať o špecifikáciu regulárnych výrazov v jazyku Python \cite{Python3Documentation}.

Ako čoskoro zistíme, nové regulárne výrazy vedia reprezentovať zložitejšie jazyky ako regulárne, preto je dobré ich nejako odlíšiť. V literatúre sa zaužíval výraz ,,regex'' z anglického \textit{regular expression}, ktorý budeme používať aj my.

\subsection{Základná definícia}

Regulárne výrazy sú zložené zo znakov a metaznakov. Znak $a$ predstavuje jazyk $L(a)=\lbrace a \rbrace$. Metaznak alebo skupina metaznakov určuje, aká operácia sa so znakmi udeje. Základné operácie sú zreťazenie (je definované tým, že regulárne výrazy idú po sebe, bez metaznaku), Kleeneho uzáver ($(0-\infty)$-krát zopakuj výraz, metaznak $*$) a alternácia (vyber výraz naľavo alebo napravo, metaznak~$|$~). Naviac sa využíva metaznak $\backslash$, ktorý robí z metaznakov obyčajné znaky a okrúhle zátvorky na logické oddelenie regulárnych výrazov.

Pre regulárny výraz $\alpha$ a slovo $w\in L(\alpha)$ hovoríme, že $\alpha$ vyhovuje slovu $w$ resp. $\alpha$ matchuje slovo $w$. Tiež budeme hovoriť, že $\alpha$ generuje jazyk $L(\alpha)$.


\subsection{Nové jednoduché konštrukcie}
\begin{itemize}
\item $+$ -- Kleeneho uzáver opakujúci $(1-\infty)$-krát
\item $\lbrace n,m \rbrace$ ($\lbrace n \rbrace$) -- opakuj regulárny výraz aspoň $n$ a najviac $m$-krát (opakuj $n$-krát)
\item $[a_1a_2\dots a_n]$ -- predstavuje ľubovoľný znak z množiny $\lbrace a_1,\dots,a_n \rbrace$
\item $[\textasciicircum a_1a_2\dots a_n]$ -- predstavuje ľubovoľný znak, ktorý nepatrí do množiny $\lbrace a_1,\dots,a_n \rbrace$
\item . -- predstavuje ľubovoľný znak
\item ? -- ak samostatne: opakuj 0 alebo 1-krát \\
ak za operáciou: namiesto greedy implementácie použi minimalistickú, t.j. zober čo najmenej znakov (platí pre $*,+,?,\lbrace n,m \rbrace$)\footnote{všetky spomenuté operácie sú implementované greedy algoritmom}
\item $\textasciicircum$ -- metaznak označujúci začiatok slova
\item \$ -- metaznak označujúci koniec slova
\item (?\# komentár) -- komentár sa pri vykonávaní regexu úplne ignoruje
\end{itemize}

Všetky tieto konštrukcie sú len ,,kozmetickou'' úpravou pôvodných regexov -- to isté vieme popísať pôvodnými regulárnymi výrazmi, akurát je to dlhšie a menej prehľadné

Rozdiely medzi minimalistickou a greedy verziou operácií vníma iba používateľ, pretože ak existuje zhoda regexu so slovom, v oboch prípadoch sa nájde. Viditeľné sú až pri výstupnej informácii pre používateľa, ktorú môže použiť ďalej.

\subsection{Zložitejšie konštrukcie}
\subsubsection*{Spätné referencie}
Najprv potrebujeme očíslovať všetky zátvorky v regexe. Číslujú sa všetky, ktoré nie sú tvaru $(?\dots)$. Poradie je určnené podľa otváracej zátvorky.

Spätné referencie umožňujú odkazovať sa na konkrétne zátvorky. Zápis je $\backslash k$ a môže sa nachádzať až za $k$-tymi zátvorkami. Skutočná hodnota $\backslash k$ sa určí až počas výpočtu -- predstavuje posledné podslovo zo vstupu, ktoré matchovali $k$-te zátvorky.

\subsubsection*{Lookahead}
Zapísaný formou $\lookahead \dots)$, vnútri je validný regex.

Keď v regexe prídeme na pozíciu lookaheadu, zoberieme regex vo vnútri. V slove sa snažíme matchovať ľubovoľný prefix zostávajúcej časti slova. Ak sa to podarí, pokračujeme v regexe ďalej a v slove od pozície, kde lookahead začínal (tzn. akokeby v regexe nikdy nebol).

Má aj negatívnu verziu -- negatívny lookahead $\nlookahead \dots)$. Vykonáva sa rovnako ako lookahead, ale má otočnú akceptáciu. Teda ak neexistuje prefix, ktorý by vedel matchovať, akceptuje.

\subsubsection*{Lookbehind}
Zapísaný formou $\lookbehind \dots)$, vnútri je validný regex.

Pri výpočte zoberieme regex vnútri lookbehindu a snažíme sa vyhovieť ľubovoľnému sufixu už matchovanej časti slova. Ak vyhovieme, pokračujeme v slove a regexe akoby tam lookbehind vôbec nebol.

Aj lookbehind má negatívnu verziu -- negatívny lookbehind $\nlookbehind \dots)$ -- a pracuje analogicky ako negatívny lookahead.
\\ \\ Lookahead a lookbehind (spolu nazývané jedným slovom lookaround) sú v rôznych implementáciách rôzne obmedzované, aby výpočet netrval príliš dlho. V teórii tieto obmedzenia ignorujeme a prezentujeme model v plnej sile -- výsledky tak prezentujú hornú hranicu toho, čo implemetnácie dokážu. 

\subsection{Triedy a množiny}
Kvôli porovnávaniu a vytvoreniu hierarchie sme rozdelili operácie do niekoľkých množín:
\begin{description}
\item[$\re$] -- množina operácií, pomocou ktorých vieme popísať iba regulárne jazyky; presnejšie všetky znaky a metaznaky (bez zložitejších operácií)
\item[$\e$] -- $\re$ so spätnými referenciami
\item[$\le$] -- $\e$ s pozitívnym lookaroundom
\item[$\nle$] -- $\le$ s negatívnym lookaroundom
\item[$\rel$] -- trieda jazykov nad $\re$ ($= \R$)
\item[$\el$] -- trieda jazykov nad $\e$
\item[$\lel$] -- trieda jazykov nad $\le$
\item[$\nlel$] -- trieda jazykov nad $\nle$
\end{description}

Trieda $\lel$ už bola hlbšie preskúmaná a výsledky čerpáme z článkov \cite{ExtendedRegexPower} a \cite{ExtendedRegexIntersec}.
 
\section{Vlastnosti lookaroundu}
Na začiatok sme zisťovali, čo robia samotné operácie lookaroundu.
\begin{theorem}
$\R$ je uzavretá na negatívny a pozitívny lookaround.
\end{theorem}
\begin{proof}
Nech $L_1,L_2,L_3\in\R$. Chceme ukázať, že $L_1\lookahead L_2)L_3, L_1\lookbehind L_2)L_3, L_1\nlookahead L_2)L_3, L_1\nlookbehind L_2,L_3 \in \R$. Pre každé $L_i$, $i \in \lbrace 1,2,3\rbrace$ existuje determinický konečný automat $A_i$, ktorý ho akceptuje. Spojíme automaty dohromady nasledujúcim spôsobom:

$L_1\lookahead L_2)L_3$: Začne výpočet $A_1$. Ak akceptuje, spustí sa naraz výpočet $A_2$ a $A_3$ ...
\end{proof}

\begin{theorem}
$\L_{CF}$ nie je uzavretá na pozitívny lookaround.
\end{theorem}
Vieme totiž vygenerovať jazyk $a^nb^nc^n$ prienikom jazykov $a*b^nc^n$ a $a^nb^nc*$.

\begin{theorem}
$\L_{CS}$ je uzavretá na pozitívny lookaround.
\end{theorem}

\begin{theorem}
Trieda jazykov nad $\re$ s pozitívnym a negatívnym lookaroundom je ekvivalentná $\R$.
\end{theorem}

\section{Chomského hierarchia}
\begin{theorem}
$\R \subsetneq \el \subseteq \lel \subsetneq \nlel \subsetneq \L_{CS}$
\end{theorem}
Všetky $\subseteq$ triviálne platia.

$\el \subsetneq \lel$: Nerovnosť dokazuje jazyk $L=\lbrace a^iba^{i+1}ba^ik ~|~ k=i(i+1)k' \text{ pre nejaké } k'>0,i>0\rbrace$. $L\notin\e$ podľa pumpovacej lemy z \cite{ExtendedRegexIntersec} a tu je regex z $\le$ pre L: 
$\alpha=\displaystyle{\mathop{(}_1 a*\mathop{)}_1 b \mathop{(}_2 \backslash 1 a \mathop{)}_2 b \lookahead (\backslash 1) *\$ ) (\backslash 2)* }$

$\lel,\nlel \subsetneq \L_{CS}$: Triedy $\lel$ a $\nlel$ sú neporovnateľné s $\L_{CF}$. K jazyku $L_1=\lbrace ww~|~w\in \lbrace a,b \rbrace^*\rbrace$ existuje regex z $\le$: $\alpha= ((a|b)*)\backslash 1$. Ani jedna z tried neobsahuje jazyk $L_2=\lbrace a^nb^n|n\in\N\rbrace$.
\\ \\
Intuitívne by malo platiť aj $\el \subsetneq \lel$, pretože negatívny lookaround pridáva uzavretosť na komplement. Jazyk dokazujúci nerovnosť by mohol byť napríklad regex $\alpha =\nlookahead ~(aa+)(\backslash 1)+ \$~)$, pričom $L(\alpha)= \lbrace a^p ~|~ p \text{ je prvočíslo} \rbrace$.

\section{Vlastnosti triedy $\lel$}

Očividne operácia lookahead/lookbehind pridala uzavretosť na prienik. Nech $\alpha,\beta\in\le$, potom $L(\alpha)\cap L(\beta) = L(\gamma)$, kde $\gamma = \lookahead \alpha \$)\beta$ alebo $\beta \lookbehind ~\textasciicircum \alpha)$.

\begin{theorem}
Nech $\alpha\in\le$ nad unárnou abecedou $\Sigma = \lbrace a \rbrace$, že neobsahuje lookahead s $\mathdollar$ ani lookbehind s $\textasciicircum$ vnútri iterácie. Existuje konštanta $N$ taká, že ak $w \in L(\alpha)$ a $\vert w \vert > N$, potom existuje dekompozícia $w=xy$ s nasledujúcimi vlastnosťami:
\begin{enumerate}[(i)]
\item $\vert y \vert \geq 1$
\item $\exists k \in \N,~k\neq 0;~\forall j = 1,2,\ldots: xy^{kj} \in L(\alpha)$
\end{enumerate}
\end{theorem}

\begin{theorem}
Jazyk všetkých platných výpočtov Turingovho stroja patrí do $\lel$.
\end{theorem}
Takýto jazyk pre konkrétny Turingov stroj obsahuje slová, ktoré sú tvorené postupnosťou konfigurácií oddelených oddeľovačom \#, ktoré zodpovedajú akceptačným výpočtom na všetkých možných vstupoch.

Turingov stroj má konečný zápis, preto je možné regex pre takýto jazyk vytvoriť. Konštrukcia regexu: $\alpha = \beta(\gamma)*\eta$, kde $\beta$ predstavuje počiatočnú konfiguráciu\footnote{Musí byť previazaná s nasledujúcou konfiguráciou, aby spĺňala $\delta$-funkciu. Spraví sa to podobne ako v $\gamma_1$.} a $\eta$ akceptačnú konfiguráciu. Ak $q_0$ je akceptačný stav, potom na koniec $\alpha$ pridáme $|(\#q_0.*\#)$. $\gamma = \gamma_1~|~\gamma_2~|~\gamma_3$.	Prvok $\gamma_i$ generuje validnú konfiguráciu a zároveň kontroluje, či nasledujúca konfigurácia môže podľa $\delta$-funkcie nasledovať. Rozpíšeme si iba jednu možnosť: 
 $ \displaystyle \gamma_1=(\mathop(_k.*\mathop)_k x q y \mathop(_{k+1} .* \mathop)_{k+1} \#)(?= \xi \#)$ platí pre $\forall q \in K,~\forall y \in \Sigma$ a kde $ \xi = \xi_1 ~|~ \xi_2 ~|~ \dots ~|~ \xi_n $.
\begin{itemize}
\item Ak $ (p,z,0) \in \delta(q,y)$, potom $\xi_i = (\backslash k~x p z \backslash k+1)$ pre nejaké $i$
\item Ak $ (p,z,1) \in \delta(q,y)$, potom $\xi_i = (\backslash k~x z p \backslash k+1)$ pre nejaké $i$
\item Ak $ (p,z,-1) \in \delta(q,y)$, potom $\xi_i = (\backslash k~p x z \backslash k+1)$ pre nejaké $i$
\end{itemize}

$\gamma_2$ a $\gamma_3$ sú podobné ako $\gamma_1$, ale matchujú krajné prípady, kedy je hlava Turingovho stroja na ľavom alebo pravom konci pásky.

\section{Priestorová zložitosť}
\section*{Poďakovanie}
Ďakujem školiteľovi za cenné rady a pripomienky.


\nocite{*}
\bibliographystyle{apalike}
\bibliography{references}

%% citacie ulozte do suboru references.bib
%% na populaciu zoznamu literatury pouzite program
%%
%% bibtex references
%%
%% po ktorom je potrebne dokument znova zlatexovat
\end{document}

