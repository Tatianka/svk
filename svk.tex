% !Mode:: "TeX::UTF-8"
\documentclass{svk_long_sk}
%% ak pisete po anglicky, pouzijete namiesto horneho riadku
%% \documentclass{svk_long_en}
\usepackage{mathrsfs}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage[shortlabels]{enumitem}

%definície pre foju
%\newtheorem{veta}{Veta}[section] 
%\newtheorem{df}[veta]{Definícia}
%\newtheorem{lema}[veta]{Lema}
%\newtheorem{dosledok}[veta]{Dôsledok}
\def\R{{\cal R}} % znak pre regulárne jazyky
\def\L{\mathscr{L}} % zvyšné triedy jazykov
\def\P{{\cal P}} % potenčná množina
\def\N{\mathds{N}} %prirodzene cisla
\def\re{Regex}
\def\e{Eregex}
\def\le{LEregex}
\def\nle{nLEregex}
\def\rel{{\mathscr{L}_{RE}}}
\def\el{\mathscr{L}_{ERE}}
\def\lel{\mathscr{L}_{LERE}}
\def\nlel{\mathscr{L}_{nLERE}}
\def\lookahead{\text{(?=}}
\def\nlookahead{\text{(?!~}}
\def\lookbehind{\text{(?\textless =}}
\def\nlookbehind{\text{(?\textless !~}}

\begin{document}
\title{Moderné regulárne výrazy}

\author{Tatiana Tóthová
\email{tothova166@uniba.sk}}
%% vsimnite si, ze u autorov sa nepisu tituly
%% prikaz \inst sluzi ako odkaz do zoznamu institucii
%% (vid. nizsie)

%% skolitela nepiste medzi autorov, ale v tejto casti
%% ak praca nema skolitela, jednoducho vynechajte
\supervisor{Michal Fori\v{s}ek
\email{forisek@dcs.fmph.uniba.sk}}

%% nasleduje kratka verzia nazvu clanku a 
%% zoznam autorov (bez krstnych mien)
%% tieto informacie sa zobrazuju v hlavicke
\titlerunning{Moderné regulárne výrazy}
\authorrunning{Tóthová}

\institute{
Katedra informatiky,
FMFI UK,
Mlynská Dolina
842~48~Bratislava}

\maketitle

\begin{abstract}
Regulárne výrazy implementované v súčasných programovacích jazykoch ponúkajú omnoho viac operácií ako pôvodný model z teórie jazykov. Už konštrukciou spätných referencií bola prekročená hranica regulárnych jazykov. Náš model obsahuje naviac konštrukcie lookahead a lookbehind. V článku uvedieme zaradenie modelu zodpovedajúcej triedy jazykov do Chomského hierarchie, vlasnosti tejto triedy a výsledky z oblasti priestorovej zložitosti.

\keywords{regulárny výraz, regex, lookahead, lookbehind, spätné referencie}
\end{abstract}

\section{Úvod}
Regulárne výrazy vznikli v 60tych rokoch v teórii jazykov ako ďalší model na vyjadrenie regulárnych jazykov. Z takéhoto popisu ľudský mozog rýchlejšie pochopil o aký jazyk sa jedná, než zo zápisu konečného automatu, či regulárnej gramatiky. Ďalšou výhodou bol kratší a kompaktný zápis.

Vďaka týmto vlastnostiam boli implementované ako vyhľadávací nástroj. Postupom času sa iniciatívou používateľov s vyššími nárokmi pridávali nové konštrukcie na uľahčenie práce. Nástroj takto rozvíjali až do dnešnej podoby. My sa budeme opierať o špecifikáciu regulárnych výrazov v jazyku Python \cite{Python3Documentation}.

Ako čoskoro zistíme, nové regulárne výrazy vedia reprezentovať zložitejšie jazyky ako regulárne, preto je dobré ich nejako odlíšiť. V literatúre sa zaužíval výraz ,,regex'' z anglického \textit{regular expression}, ktorý budeme používať aj my.

\subsection{Základná definícia}

Regulárne výrazy sú zložené zo znakov a metaznakov. Znak $a$ predstavuje jazyk $L(a)=\lbrace a \rbrace$. Metaznak alebo skupina metaznakov určuje, aká operácia sa so znakmi udeje. Základné operácie sú zreťazenie (je definované tým, že regulárne výrazy idú po sebe, bez metaznaku), Kleeneho uzáver ($(0-\infty)$-krát zopakuj výraz, metaznak $*$) a alternácia (vyber výraz naľavo alebo napravo, metaznak~$|$~). Naviac sa využíva metaznak $\backslash$, ktorý robí z metaznakov obyčajné znaky a okrúhle zátvorky na logické oddelenie regulárnych výrazov.

Pre regulárny výraz $\alpha$ a slovo $w\in L(\alpha)$ hovoríme, že $\alpha$ vyhovuje slovu $w$ resp. $\alpha$ matchuje slovo $w$. Tiež budeme hovoriť, že $\alpha$ generuje jazyk $L(\alpha)$.


\subsection{Nové jednoduché konštrukcie}
\begin{itemize}
\item $+$ -- Kleeneho uzáver opakujúci $(1-\infty)$-krát
\item $\lbrace n,m \rbrace$ ($\lbrace n \rbrace$) -- opakuj regulárny výraz aspoň $n$ a najviac $m$-krát (opakuj $n$-krát)
\item $[a_1a_2\dots a_n]$ -- predstavuje ľubovoľný znak z množiny $\lbrace a_1,\dots,a_n \rbrace$
\item $[\textasciicircum a_1a_2\dots a_n]$ -- predstavuje ľubovoľný znak, ktorý nepatrí do množiny $\lbrace a_1,\dots,a_n \rbrace$
\item . -- predstavuje ľubovoľný znak
\item ? -- ak samostatne: opakuj 0 alebo 1-krát \\
ak za operáciou: namiesto greedy implementácie použi minimalistickú, t.j. zober čo najmenej znakov (platí pre $*,+,?,\lbrace n,m \rbrace$)\footnote{všetky spomenuté operácie sú implementované greedy algoritmom}
\item $\textasciicircum$ -- metaznak označujúci začiatok slova
\item \$ -- metaznak označujúci koniec slova
\item (?\# komentár) -- komentár sa pri vykonávaní regexu úplne ignoruje
\end{itemize}

Všetky tieto konštrukcie sú len ,,kozmetickou'' úpravou pôvodných regexov -- to isté vieme popísať pôvodnými regulárnymi výrazmi, akurát je to dlhšie a menej prehľadné

Rozdiely medzi minimalistickou a greedy verziou operácií vníma iba používateľ, pretože ak existuje zhoda regexu so slovom, v oboch prípadoch sa nájde. Viditeľné sú až pri výstupnej informácii pre používateľa, ktorú môže použiť ďalej.

\subsection{Zložitejšie konštrukcie}
\subsubsection*{Spätné referencie}
Najprv potrebujeme očíslovať všetky zátvorky v regexe. Číslujú sa všetky, ktoré nie sú tvaru $(?\dots)$. Poradie je určnené podľa otváracej zátvorky.

Spätné referencie umožňujú odkazovať sa na konkrétne zátvorky. Zápis je $\backslash k$ a môže sa nachádzať až za $k$-tymi zátvorkami. Skutočná hodnota $\backslash k$ sa určí až počas výpočtu -- predstavuje posledné podslovo zo vstupu, ktoré matchovali $k$-te zátvorky.

\subsubsection*{Lookahead}
Zapísaný formou $\lookahead \dots)$, vnútri je validný regex.

Keď v regexe prídeme na pozíciu lookaheadu, zoberieme regex vo vnútri. V slove sa snažíme matchovať ľubovoľný prefix zostávajúcej časti slova. Ak sa to podarí, pokračujeme v regexe ďalej a v slove od pozície, kde lookahead začínal (tzn. akokeby v regexe nikdy nebol).

Má aj negatívnu verziu -- negatívny lookahead $\nlookahead \dots)$. Vykonáva sa rovnako ako lookahead, ale má otočnú akceptáciu. Teda ak neexistuje prefix, ktorý by vedel matchovať, akceptuje.

\subsubsection*{Lookbehind}
Zapísaný formou $\lookbehind \dots)$, vnútri je validný regex.

Pri výpočte zoberieme regex vnútri lookbehindu a snažíme sa vyhovieť ľubovoľnému sufixu už matchovanej časti slova. Ak vyhovieme, pokračujeme v slove a regexe akoby tam lookbehind vôbec nebol.

Aj lookbehind má negatívnu verziu -- negatívny lookbehind $\nlookbehind \dots)$ -- a pracuje analogicky ako negatívny lookahead.
\\ \\ Lookahead a lookbehind (spolu nazývané jedným slovom lookaround) sú v rôznych implementáciách rôzne obmedzované, aby výpočet netrval príliš dlho. V teórii tieto obmedzenia ignorujeme a prezentujeme model v plnej sile -- výsledky tak prezentujú hornú hranicu toho, čo implemetnácie dokážu. 

\subsection{Priorita}

Pri interakcii toľkých operácií je nutné vedieť ich priority. Existujú také, ktoré sa správajú ako znak, čomu zodpovedajú [],[\textasciicircum],. a každá spätná referencia. Špeciálne sú lookahead a lookbehind -- tie sa vykonajú hneď akonáhle na ne narazíme. Ostatné zoradíme v tabuľke: 

\begin{center}
\begin{tabular}{|c||c|c|c|c|}
\hline
priorita &3&2&1& 0  \\
\hline
operácia & () & $*$ + ? $\lbrace \rbrace$ & zreťazenie & | \\ \hline
\end{tabular}
\end{center}

\subsection{Triedy a množiny}
Kvôli porovnávaniu a vytvoreniu hierarchie sme rozdelili operácie do niekoľkých množín:
\begin{description}
\item[$\re$] -- množina operácií, pomocou ktorých vieme popísať iba regulárne jazyky; presnejšie všetky znaky a metaznaky (bez zložitejších operácií)
\item[$\e$] -- $\re$ so spätnými referenciami
\item[$\le$] -- $\e$ s pozitívnym lookaroundom
\item[$\nle$] -- $\le$ s negatívnym lookaroundom
\item[$\rel$] -- trieda jazykov nad $\re$ ($= \R$)
\item[$\el$] -- trieda jazykov nad $\e$
\item[$\lel$] -- trieda jazykov nad $\le$
\item[$\nlel$] -- trieda jazykov nad $\nle$
\end{description}

Trieda $\lel$ už bola hlbšie preskúmaná a výsledky čerpáme z článkov \cite{ExtendedRegexPower} a \cite{ExtendedRegexIntersec}.
 
\section{Formalizácia modelu}
Pri zložitejších dôkazoch sa ukázala potreba lepšieho formalizmu, než len množiny operácií. Kvôli jednoduchosti sme vybrali len potrebné operácie -- zreťazenie, alternáciu, Kleeneho $*$, spätné referencie a pozitívny a negatívny lookaround -- a pokúsili sa ho vyjadriť ako model, ktorý pracuje v krokoch podobne ako Turingov stroj.

Základným prvkom je \textbf{konfigurácia}. Je to dvojica regex $r_1 \dots r_n$ a vstupné slovo $w_1 \dots w_m$, pričom v oboch reťazcoch sa navyše nachádza ukazovateľ pozície $\lceil$ (ako hlava Turingovho stroja): $(r_1\dots \lceil r_i\dots r_n,w_1 \dots \lceil w_j \dots w_m)$. Špeciálne rozoznávame počiatočnú konfiguráciu $(\lceil r_1 \dots r_n,\lceil w_1 \dots w_m)$ a akceptačnú konfiguráciu $(r_1 \dots r_n \lceil, w_1 \dots w_m \lceil)$.

Najprv si definujeme potrebné pojmy indexovateľnosti a alternovateľnosti. \textit{Indexovateľné zátvorky} sú také, kde za otváracou zátvorkou nenasleduje ? (t.j. všetky prípady okrem lookaroundu). Tieto zátvorky budeme číslovať. \textit{Alternovateľný regex} je taký, ktorý sa môže vyskytovať v alternácii. Sú 3 prípady: regex sa môže nachádzať naľavo od $|$, napravo od $|$ alebo je z oboch strán ohraničený $|$. Ak alternácia nie je uzavretá zátvorkami, ľavý a pravý krajný regex siaha až ku kraju slova, pretože alternácia je operácia s najmenšou prioritou. Inak sú pre nich hranicou zátvorky uzatváracie alternáciu.

Vďaka definovaniu týchto pojmov vidíme, že vieme algoritmicky zistiť, ktoré zátvorky sú indexovateľné a ktoré regexy sú alternovateľné.

Definujeme \textbf{krok výpočtu} ako reláciu $\vdash$ na konfiguráciách ...

\textbf{Akceptačný výpočet} je postupnosť konfigurácií $(\lceil R, \lceil W) \vdash^* (R\lceil,w\lceil)$. Ak existuje akceptačný výpočet pre daný regex $R$ a slovo $W$ hovoríme, že regex $R$ matchuje slovo $W$ respektívne slovo $W$ vyhovuje regexu $R$. \textbf{Jazyk} vyhovujúci danému regexu je množina slov, pre ktoré existuje akceptačný výpočet.
\\ \\ Vďaka týmto definíciám sme schopný odhadnúť dĺžku výpočtu:
\begin{theorem}
Nech $\alpha \in \lel$ a $w \in L(\alpha)$. Potom existuje akceptačný výpočet, ktorý má najviac $O(|\alpha|\cdot|w|)$ konfigurácií.
\end{theorem}
\begin{proof}
Vo väčšine krokov výpočtu sa posúvame dopredu buď v regexe alebo v slove alebo v oboch. Takéto kroky vedú k postupnosti dĺžky $O(|\alpha|+|w|)$.

Výpočet môže predĺžiť skákanie ukazovateľa dozadu. To nastáva iba v prípade, ak v regexe ukazujeme na Kleeneho $*$ a rozhodneme sa skočiť v regexe dozadu, aby sme urobili ďalšiu iteráciu. Zamyslime sa nad samotným akceptačným výpočtom. Ak existuje, potom existuje aj taká jeho verzia, kde každé opakovanie regexu pomocou Kleeneho $*$ matchuje aspoň 1 znak -- prázdne iterácie môžeme vyhodiť, lebo ukazovateľ v slove zostal na mieste a konfigurácia skoku je rovnaká, takže sa postupnosť priamo napojí. Vieme, že regex opakovaný operáciou $*$ je dlhý $O(|\alpha|)$ znakov a opakujeme najviac $O(|w|)$-krát.

Teda dokopy spravíme najviac $O(|\alpha|+|w|) + O(|\alpha|\cdot|w|) = O(|\alpha|\cdot|w|)$ krokov.
\end{proof}
 
\section{Vlastnosti lookaroundu}
Na začiatok sme zisťovali, čo robia samotné operácie lookaroundu.
\begin{theorem}
$\R$ je uzavretá na negatívny a pozitívny lookaround.
\end{theorem}
\begin{proof}
Nech $L_1,L_2,L_3\in\R$. Chceme ukázať, že $L_1\lookahead L_2)L_3,~ L_1\lookbehind L_2)L_3,~ L_1\nlookahead L_2)L_3,~ L_1\nlookbehind L_2)L_3 \in \R$. Pre každé $L_i$, $i \in \lbrace 1,2,3\rbrace$ existuje determinický konečný automat $A_i$, ktorý ho akceptuje.

Konečné automaty vieme vhodne pospájať dohromady. Spravíme konštrukciu pre prienik regulárnych jazykov, ale mierne upravenú tak, že akonáhle automat pre $L_2$ v pozitívnom lookaheade akceptuje, vo výpočte bude pokračovať už len samotný $A_3$, kým dočíta slovo. Podobne pre pozitívny lookbehind -- $A_1$ začne sám a nedeterministicky v nejakom kroku začne výpočet aj $A_2$. Akceptovať musia spolu.

Pre negatívne formy musíme navyše upraviť akceptáciu. Ak $A_2$ pre lookahead akceptuje, celý automat sa zasekne a zamietne. $A_2$ musí dočítať slovo bez dosiahnutia akceptačného stavu. Pre lookbehind v každom kroku $A_1$ spúšťame ďalší $A_2$ a držíme si množinu stavov, v ktorých sa všetky nachádzajú. Úspech je, ak $A_1$ akceptuje a množina stavov pre automaty $A_2$ neobsahuje akceptačný stav.

Odhliadnuc teraz od lookaroundu, máme zreťazenie $L_1$ a $L_3$. Preto prepojíme akceptačný stav $A_1$ s počiatočným stavom $A_3$. Výsledný automat sa nedeterministicky rozhoduje, či z akceptačného stavu $A_1$ pokračuje ďalej v $A_1$ alebo $A_3$.
\end{proof}

\begin{theorem}
$\L_{CF}$ nie je uzavretá na pozitívny lookaround.
\end{theorem}
Vieme totiž vygenerovať jazyk $a^nb^nc^n$ prienikom jazykov $a*b^nc^n$ a $a^nb^nc*$.

\begin{theorem}
$\L_{CS}$ je uzavretá na pozitívny lookaround.
\end{theorem}

\begin{theorem}
Trieda jazykov nad $\re$ s pozitívnym a negatívnym lookaroundom je ekvivalentná $\R$.
\end{theorem}

\section{Chomského hierarchia}
\begin{theorem}
$\R \subsetneq \el \subsetneq \lel \subseteq \nlel \subsetneq \L_{CS}$
\end{theorem}
\begin{proof}

Všetky $\subseteq$ triviálne platia.

$\el \subsetneq \lel$: Nerovnosť dokazuje jazyk $L=\lbrace a^iba^{i+1}ba^ik ~|~ k=i(i+1)k' \text{ pre nejaké } k'>0,i>0\rbrace$. $L\notin\e$ podľa pumpovacej lemy z \cite{ExtendedRegexIntersec} a tu je regex z $\le$ pre L: 
$\alpha=\displaystyle{\mathop{(}_1 a*\mathop{)}_1 b \mathop{(}_2 \backslash 1 a \mathop{)}_2 b \lookahead (\backslash 1) *\$ ) (\backslash 2)* }$

$\lel,\nlel \subsetneq \L_{CS}$: Triedy $\lel$ a $\nlel$ sú neporovnateľné s $\L_{CF}$. K jazyku $L_1=\lbrace ww~|~w\in \lbrace a,b \rbrace^*\rbrace \notin \L_{CF}$ existuje regex z $\le$: $\alpha= ((a|b)*)\backslash 1$. Ani jedna z tried neobsahuje jazyk $L_2=\lbrace a^nb^n|n\in\N\rbrace \in \L_{CF}$.
\end{proof}

Intuitívne by malo platiť aj $\lel \subsetneq \nlel$, pretože negatívny lookaround pridáva uzavretosť na komplement. Jazyk dokazujúci nerovnosť by mohol byť napríklad regex $\alpha =\nlookahead ~(aa+)(\backslash 1)+ \$~)$, pričom $L(\alpha)= \lbrace a^p ~|~ p \text{ je prvočíslo} \rbrace$.

\section{Vlastnosti triedy $\lel$}

Očividne operácia lookahead/lookbehind pridala uzavretosť na prienik. Nech $\alpha,\beta\in\le$, potom $L(\alpha)\cap L(\beta) = L(\gamma)$, kde $\gamma = \lookahead \alpha \$)\beta$ alebo $\beta \lookbehind ~\textasciicircum \alpha)$.

Napak ohrozila uzavretosť na základnú operáciu -- zreťazenie. Pri zreťazení 2 jazykov, ktorých regexy nutne musia obsahovať lookahead resp. lookbehind nastáva problém. Nemôžeme tieto regexy len tak položiť za seba. Ak sa napríklad v prvom z jazykov nachádza lookahead, počas výpočtu môže zasahovať aj do časti vstupu, ktorú matchuje druhý regex a tým zmeniť výsledok celého výpočtu. Nakoniec sa ukázalo:
\begin{theorem}
$\lel$ je uzavretá na zreťazenie.
\end{theorem}
\begin{proof}
Nech $\alpha,\beta\in\le$. Jazyku $L(\alpha)L(\beta)$ bude zodpovedať regex
$$
\gamma = \lookahead \mathop(_1 \alpha \mathop)_1 \mathop(_{k+2}\beta \mathop)_{k+2} \mathdollar) ~\alpha ' \backslash k\text{+2}~ \lookbehind ~\textasciicircum\backslash 1~\beta ')
$$
V $\alpha,\beta$ treba vhodne prepísať označenie zátvoriek (po poradí). $\alpha '$ je $\alpha$ prepísaný tak, že pre každý lookahead:
\begin{itemize}
\item bez \$ -- na koniec pridáme $.* \backslash k+2 \mathdollar $
\item s \$ -- pred \$ pridáme $\backslash k+2$
\end{itemize}
$\beta '$ je $\beta$ prepísaný tak, že pre každý lookbehind:
\begin{itemize}
\item bez $\textasciicircum$ -- na začiatok pridáme $\textasciicircum \backslash 1.*$
\item s $\textasciicircum$ -- pred $\textasciicircum$ pridáme $\textasciicircum \backslash 1$
\end{itemize}

Slovami vyjadrené, regex $\gamma$ najprv rozdelí vstupné slovo na 2 podslová $w_1,w_2$ patriace do príslušných jazykov $L(\alpha), L(\beta)$. Potom spustí ešte raz regex $\alpha$ upravený tak, že jeho lookaheady sú ,,skrotené'', pretože ich na konci donúti matchovať $w_2$. Rovnako lookbehindy v $\beta'$ donúti na začiatku matchovať $w_1$, až potom normálne pokračuje ich výpočet.

Zrejme $L(\gamma)=L(\alpha)L(\beta)$.
\end{proof}

\begin{theorem}
Nech $\alpha\in\le$ nad unárnou abecedou $\Sigma = \lbrace a \rbrace$, že neobsahuje lookahead s $\mathdollar$ ani lookbehind s $\textasciicircum$ vnútri iterácie. Existuje konštanta $N$ taká, že ak $w \in L(\alpha)$ a $\vert w \vert > N$, potom existuje dekompozícia $w=xy$ s nasledujúcimi vlastnosťami:
\begin{enumerate}[(i)]
\item $\vert y \vert \geq 1$
\item $\exists k \in \N,~k\neq 0;~\forall j = 1,2,\ldots: xy^{kj} \in L(\alpha)$
\end{enumerate}
\end{theorem}

\begin{theorem}
Jazyk všetkých platných výpočtov Turingovho stroja patrí do $\lel$.
\end{theorem}
\begin{proof}
Takýto jazyk pre konkrétny Turingov stroj $M$ obsahuje slová, ktoré sú tvorené postupnosťou konfigurácií oddelených oddeľovačom \#. Každá postupnosť zodpovedá akceptačnému výpočtu na nejakom slove. Jazyk obsahuje akceptačné výpočty na všetkých slovách, ktoré sú v jazyku $L(M)$.

Turingov stroj má konečný zápis, preto je možné regex pre takýto jazyk vytvoriť. Konštrukcia regexu: $\alpha = \beta(\gamma)*\eta$, kde $\beta$ predstavuje počiatočnú konfiguráciu\footnote{Musí byť previazaná s nasledujúcou konfiguráciou, aby spĺňala $\delta$-funkciu. Spraví sa to pomocou lookaheadu, podobne ako v $\gamma_1$.} a $\eta$ akceptačnú konfiguráciu. Ak $q_0$ je akceptačný stav, potom na koniec $\alpha$ pridáme $|(\#q_0.*\#)$. $\gamma = \gamma_1~|~\gamma_2~|~\gamma_3$.	Prvok $\gamma_i$ generuje validnú konfiguráciu a zároveň kontroluje pomocou lookaheadu, či nasledujúca konfigurácia môže podľa $\delta$-funkcie nasledovať. Rozpíšeme si iba jednu možnosť: 
 $$ \displaystyle \gamma_1=(\mathop(_k.*\mathop)_k x q y \mathop(_{k+1} .* \mathop)_{k+1} \#)(?= \xi \#)$$ platí pre $\forall q \in K,~\forall y \in \Sigma$ a kde $ \xi = \xi_1 ~|~ \xi_2 ~|~ \dots ~|~ \xi_n $.
\begin{itemize}
\item Ak $ (p,z,0) \in \delta(q,y)$, potom $\xi_i = (\backslash k~x p z \backslash k+1)$ pre nejaké $i$
\item Ak $ (p,z,1) \in \delta(q,y)$, potom $\xi_i = (\backslash k~x z p \backslash k+1)$ pre nejaké $i$
\item Ak $ (p,z,-1) \in \delta(q,y)$, potom $\xi_i = (\backslash k~p x z \backslash k+1)$ pre nejaké $i$
\end{itemize}

$\gamma_2$ a $\gamma_3$ sú podobné ako $\gamma_1$, ale matchujú krajné prípady, kedy je hlava Turingovho stroja na ľavom alebo pravom konci pásky.

Zrejme $L(\gamma)$ je požadovaný jazyk.
\end{proof}

\section{Priestorová zložitosť}
\begin{theorem}
$\lel \subsetneq NSPACE(\log n)$, kde $n$ je veľkosť vstupu.
\end{theorem}
Dôsledok Savitchovej vety:
\begin{theorem}
$\lel \subsetneq DSPACE(\log^2 n)$, kde $n$ je veľkosť vstupu.
\end{theorem}
\begin{theorem}
$\nlel \subsetneq DSPACE(\log^2 n)$, kde $n$ je veľkosť vstupu.
\end{theorem}

\begin{theorem}
$L(regex\#word) \in NSPACE(r \log w)$, kde $r = |regex|,~w = |word|$ a $regex \in \le$.
\end{theorem}
\begin{theorem}
$L(regex\#word) \in DSPACE(n \log^2 n)$, kde $regex \in \le$ a $n$ je dĺžka vstupu.
\end{theorem}
\section*{Poďakovanie}
Ďakujem školiteľovi za cenné rady a pripomienky.


\nocite{*}
\bibliographystyle{apalike}
\bibliography{references}

\end{document}

